# 架构决策记录（ADR）

## 文档信息

- **创建日期**: 2026-02-14
- **更新日期**: 2026-02-14
- **状态**: 已批准
- **决策来源**: Week 1 项目启动评审会议 + 实际实施

---

## ADR-001: 采用 PostgreSQL 作为统一数据库

### 背景

项目需要选择合适的数据库来存储用户、会议、消息等数据。

### 决策

采用 **PostgreSQL 14+** 作为统一的关系型数据库。

### 理由

**优势**:
1. **功能强大**: 支持 JSONB、全文搜索、地理位置等高级特性
2. **性能优秀**: 支持复杂查询优化、并发控制良好
3. **开源成熟**: 社区活跃、文档完善、生态丰富
4. **扩展性好**: 支持分区表、复制、外部表等
5. **类型安全**: 严格的数据类型系统

**与其他方案对比**:
- **MySQL**: PostgreSQL 在复杂查询和 JSONB 支持上更优
- **MongoDB**: 关系型数据更适合会议系统的业务逻辑
- **分库分表**: MVP 阶段无需考虑，PostgreSQL 单库可支持百万级数据

### 影响

- ✅ 统一技术栈，降低维护成本
- ✅ 团队熟悉 PostgreSQL，上手快
- ✅ 支持 TypeORM，ORM 集成方便
- ⚠️ 需要做好连接池配置和查询优化

### 实施状态

✅ **已实施** - 已在 `apps/backend` 中集成 PostgreSQL + TypeORM

---

## ADR-002: 使用 Redis Pub/Sub 实现信令高可用

### 背景

多个信令服务器实例需要同步会议状态和用户消息，确保高可用性。

### 决策

采用 **Redis Pub/Sub + Room 分配策略** 实现信令服务的高可用。

### 方案设计

#### 架构

```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│  Client 1   │────→│ Signaling 1 │     │ Signaling 2 │
└─────────────┘     └──────┬──────┘     └──────┬──────┘
                           │                    │
                           └────────┬───────────┘
                                    │
                              ┌─────▼─────┐
                              │   Redis   │
                              │  Pub/Sub  │
                              └───────────┘
```

#### Room 分配策略

1. **一致性哈希**: 根据 `meeting_id` 哈希到特定信令服务器
2. **动态迁移**: 服务器下线时，会议迁移到其他服务器
3. **状态同步**: 通过 Redis Pub/Sub 广播状态变更

#### 消息流

```typescript
// 用户加入会议
Client → Signaling Server 1 → Redis Pub/Sub → All Signaling Servers
```

### 理由

**优势**:
1. **简单可靠**: Redis Pub/Sub 成熟稳定
2. **低延迟**: 内存操作，毫秒级延迟
3. **易于扩展**: 水平扩展信令服务器
4. **状态同步**: 自动广播到所有订阅者

**与其他方案对比**:
- **WebSocket Cluster**: 需要额外的集群管理
- **RabbitMQ**: 过于重量级，Redis 足够
- **Kafka**: 适合大数据流，信令场景过度设计

### 影响

- ✅ 支持多实例部署，提高可用性
- ✅ Redis 本身可做主从，保证可靠性
- ⚠️ Redis 单点故障风险（通过主从和哨兵解决）

### 实施状态

🔜 **规划中** - Redis 已集成，Pub/Sub 逻辑待实现

---

## ADR-003: mediasoup SFU + FFmpeg 录制方案

### 背景

需要服务端录制会议音视频，生成可回放的视频文件。

### 决策

采用 **mediasoup → WebM → FFmpeg → MP4** 的录制方案。

### 方案设计

#### 录制流程

```
mediasoup SFU
    ↓ (RTP 流)
录制 Worker
    ↓ (合成)
WebM 文件
    ↓ (转码)
FFmpeg
    ↓
MP4 文件
    ↓
对象存储 (S3/OSS)
```

#### 关键步骤

1. **音视频合流**: mediasoup 将多路流合成为单路
2. **实时录制**: 写入 WebM 格式（高效）
3. **异步转码**: 会议结束后用 FFmpeg 转 MP4
4. **上传存储**: 上传到对象存储，生成下载链接

### 理由

**优势**:
1. **mediasoup 原生支持**: 集成简单，性能好
2. **WebM 高效**: 实时录制延迟低
3. **MP4 兼容性**: 所有平台支持
4. **异步转码**: 不影响会议性能

**与其他方案对比**:
- **客户端录制**: 依赖客户端，可靠性差
- **直接录 MP4**: 实时编码压力大
- **云服务录制**: 成本高，依赖第三方

### 影响

- ✅ 服务端可控，可靠性高
- ✅ 支持画中画、多布局
- ⚠️ 需要额外的转码服务器资源
- ⚠️ 存储成本需考虑（定期清理）

### 实施状态

🔜 **规划中** - Phase 3 实施（Week 7-8）

---

## ADR-004: Web/Electron 代码复用 Monorepo 架构

### 背景

Web 端和 Electron 桌面端需要共享大部分代码，减少重复开发。

### 决策

采用 **Monorepo + Turborepo** 架构，实现 80-85% 代码复用。

### 方案设计

#### 目录结构

```
ai_meeting/
├── apps/
│   ├── web/              # Web 应用
│   └── electron/         # Electron 应用
│       ├── src/main/     # 主进程（平台特定）
│       └── src/renderer/ # 渲染进程（复用 Web）
└── packages/
    ├── shared/           # 共享类型、工具
    └── ui/               # 共享 UI 组件
```

#### 复用策略

| 代码类型 | Web | Electron | 复用率 |
|---------|-----|----------|--------|
| UI 组件 | ✅ | ✅ | 100% |
| 业务逻辑 | ✅ | ✅ | 100% |
| 状态管理 | ✅ | ✅ | 100% |
| 类型定义 | ✅ | ✅ | 100% |
| 平台 API | ✅ | ❌ | 0% |

**实际验证结果**: 80.7% 代码复用率 ✅

### 理由

**优势**:
1. **高复用**: 渲染进程 100% 复用 Web 代码
2. **统一管理**: 单个仓库，依赖版本统一
3. **快速构建**: Turborepo 缓存和并行构建
4. **类型安全**: TypeScript 跨包类型共享

**与其他方案对比**:
- **多仓库**: 代码同步困难，版本管理复杂
- **全复用**: Electron 主进程必须独立实现

### 影响

- ✅ 开发效率显著提升
- ✅ Bug 修复一次生效两端
- ✅ 新功能开发周期缩短
- ⚠️ 需要良好的平台差异封装

### 实施状态

✅ **已实施** - Monorepo 已搭建，代码复用率验证通过

---

## ADR-005: NestJS 后端框架 + DDD 分层架构

### 背景

后端需要选择合适的框架和架构模式，支持快速开发和长期维护。

### 决策

采用 **NestJS + DDD 分层架构**。

### 方案设计

#### 分层架构

```
API 层 (Controllers/WebSocket)
    ↓
应用层 (Use Cases/Application Services)
    ↓
领域层 (Domain Entities/Domain Services)
    ↓
基础设施层 (Database/Cache/External Services)
```

#### 核心原则

1. **依赖倒置**: 内层不依赖外层
2. **单一职责**: 每层职责明确
3. **依赖注入**: 松耦合，易测试
4. **领域驱动**: 业务逻辑集中在领域层

### 理由

**NestJS 优势**:
1. **TypeScript 原生支持**: 类型安全
2. **依赖注入**: 成熟的 IoC 容器
3. **模块化**: 清晰的模块边界
4. **生态丰富**: 集成 TypeORM、Passport 等

**DDD 优势**:
1. **业务逻辑清晰**: 与代码模型一致
2. **易于测试**: 领域层独立于技术实现
3. **可维护性**: 职责分离，易于理解
4. **可扩展性**: 为微服务化预留空间

### 影响

- ✅ 代码结构清晰，新人易上手
- ✅ 业务逻辑与技术实现分离
- ✅ 单元测试覆盖率高
- ⚠️ 学习曲线略陡（团队培训）

### 实施状态

✅ **已实施** - NestJS 框架已搭建，DDD 目录结构已创建

---

## ADR-006: MVP 阶段平台范围限定

### 背景

资源有限，需要确定 MVP 阶段支持的平台范围。

### 决策

**MVP (v0.1) 仅支持 Web + Electron**，iOS/Android 延后到 v0.2。

### 理由

**聚焦核心**:
1. **技术验证**: WebRTC + SFU 核心技术优先验证
2. **主要场景**: 企业会议以桌面端为主
3. **开发效率**: Web/Electron 代码复用率高，开发快
4. **质量保证**: 12 周内保证两端高质量交付

**移动端延后原因**:
1. **额外工作量**: iOS/Android 原生开发工作量大
2. **资源分散**: 同时开发四端会分散资源
3. **风险高**: 跨平台一致性测试复杂

### 影响

- ✅ 聚焦核心功能，降低风险
- ✅ MVP 交付时间可控
- ✅ 技术架构验证充分
- ⚠️ 移动端市场延后进入

### 实施状态

✅ **已确认** - 项目按此策略推进

---

## ADR-007: JWT 认证 + Refresh Token 机制

### 背景

需要安全可靠的用户认证方案。

### 决策

采用 **JWT + Refresh Token** 双令牌机制。

### 方案设计

#### Token 配置

| Token 类型 | 有效期 | 存储位置 | 用途 |
|-----------|-------|---------|------|
| Access Token | 1 小时 | 内存 | API 访问 |
| Refresh Token | 7 天 | HttpOnly Cookie | 刷新 Access Token |

#### 认证流程

```
登录成功
    ↓
返回 Access Token (1h) + Refresh Token (7d)
    ↓
客户端使用 Access Token 访问 API
    ↓
Access Token 过期
    ↓
使用 Refresh Token 获取新 Access Token
    ↓
Refresh Token 过期
    ↓
重新登录
```

### 理由

**优势**:
1. **安全性**: Access Token 短期，即使泄露风险小
2. **用户体验**: Refresh Token 自动续期，无需频繁登录
3. **可控性**: 可随时撤销 Refresh Token
4. **无状态**: JWT 自包含，无需服务端存储会话

**与其他方案对比**:
- **Session**: 需要服务端存储，扩展性差
- **单 Token**: 长期 Token 泄露风险高
- **OAuth**: 过于复杂，MVP 阶段不需要

### 影响

- ✅ 兼顾安全性和用户体验
- ✅ 支持水平扩展（无状态）
- ⚠️ 需要实现 Token 刷新逻辑

### 实施状态

🔜 **规划中** - JWT 模块已集成，认证逻辑待实现

---

## 决策汇总

| ADR | 决策内容 | 状态 | 优先级 |
|-----|---------|------|--------|
| ADR-001 | PostgreSQL 统一数据库 | ✅ 已实施 | P0 |
| ADR-002 | Redis Pub/Sub 信令 HA | 🔜 规划中 | P0 |
| ADR-003 | mediasoup + FFmpeg 录制 | 🔜 规划中 | P1 |
| ADR-004 | Monorepo 代码复用 | ✅ 已实施 | P0 |
| ADR-005 | NestJS + DDD 架构 | ✅ 已实施 | P0 |
| ADR-006 | MVP 平台范围限定 | ✅ 已确认 | P0 |
| ADR-007 | JWT 双令牌认证 | 🔜 规划中 | P0 |

---

## 技术栈总览

### 前端技术栈

| 技术 | 版本 | 用途 |
|------|------|------|
| React | 18.x | UI 框架 |
| TypeScript | 5.3.x | 类型安全 |
| Zustand | 4.4.x | 状态管理 |
| React Router | 6.x | 路由 |
| Tailwind CSS | 3.4.x | 样式 |
| Vite | 5.x | 构建工具 |

### 后端技术栈

| 技术 | 版本 | 用途 |
|------|------|------|
| NestJS | 10.x | 后端框架 |
| TypeScript | 5.3.x | 类型安全 |
| PostgreSQL | 14+ | 数据库 |
| Redis | 7+ | 缓存/Pub-Sub |
| TypeORM | 0.3.x | ORM |
| JWT | - | 认证 |
| Winston | 3.x | 日志 |

### 客户端技术栈

| 技术 | 版本 | 用途 |
|------|------|------|
| Electron | 28.x | 桌面应用 |
| React | 18.x | UI（复用 Web） |

### 音视频技术栈

| 技术 | 版本 | 用途 |
|------|------|------|
| WebRTC | - | 实时通信 |
| mediasoup | 3.x | SFU 服务器 |
| FFmpeg | 4.x | 录制转码 |

### 构建与部署

| 技术 | 版本 | 用途 |
|------|------|------|
| pnpm | 8.x | 包管理 |
| Turborepo | 1.x | Monorepo 构建 |
| Docker | - | 容器化 |
| GitHub Actions | - | CI/CD |

---

## 后续决策

### 待决策事项

1. **对象存储选型**: S3 vs 阿里云 OSS vs 自建 MinIO
2. **消息队列**: RabbitMQ vs Redis Streams vs Kafka
3. **监控方案**: Prometheus + Grafana vs 云服务
4. **日志方案**: ELK vs Loki vs 云服务
5. **CDN 选型**: CloudFlare vs 阿里云 CDN

### 决策时间点

- **Week 3**: 对象存储选型（录制功能需要）
- **Week 5**: 监控和日志方案（生产部署前）
- **Week 8**: CDN 选型（性能优化阶段）

---

**文档版本**: v1.0
**创建日期**: 2026-02-14
**维护人**: Architect Team
**审核状态**: 已批准
